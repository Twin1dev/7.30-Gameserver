#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_Perk_C_Constructor_BASE

#include "Basic.hpp"

#include "B_Perk_C_Constructor_BASE_classes.hpp"
#include "B_Perk_C_Constructor_BASE_parameters.hpp"


namespace SDK
{

// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ExecuteUbergraph_B_Perk_C_Constructor_BASE
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::ExecuteUbergraph_B_Perk_C_Constructor_BASE(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ExecuteUbergraph_B_Perk_C_Constructor_BASE");

	Params::B_Perk_C_Constructor_BASE_C_ExecuteUbergraph_B_Perk_C_Constructor_BASE Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BndEvt__P_FeeltheBase_Chargup_K2Node_ComponentBoundEvent_0_ParticleBurstSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EmitterTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ParticleCount                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::BndEvt__P_FeeltheBase_Chargup_K2Node_ComponentBoundEvent_0_ParticleBurstSignature__DelegateSignature(class FName EventName, float EmitterTime, int32 ParticleCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BndEvt__P_FeeltheBase_Chargup_K2Node_ComponentBoundEvent_0_ParticleBurstSignature__DelegateSignature");

	Params::B_Perk_C_Constructor_BASE_C_BndEvt__P_FeeltheBase_Chargup_K2Node_ComponentBoundEvent_0_ParticleBurstSignature__DelegateSignature Parms{};

	Parms.EventName = EventName;
	Parms.EmitterTime = EmitterTime;
	Parms.ParticleCount = ParticleCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ResetFeelTheBaseGlow
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::ResetFeelTheBaseGlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ResetFeelTheBaseGlow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.FeelTheBaseGlow
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Stack1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Stack2                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Stack3                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Perk_C_Constructor_BASE_C::FeelTheBaseGlow(bool Stack1, bool Stack2, bool Stack3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "FeelTheBaseGlow");

	Params::B_Perk_C_Constructor_BASE_C_FeelTheBaseGlow Parms{};

	Parms.Stack1 = Stack1;
	Parms.Stack2 = Stack2;
	Parms.Stack3 = Stack3;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SaveOwner
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerPawn_Constructor_C*        Param_ConstructorPawn                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SaveOwner(class APlayerPawn_Constructor_C* Param_ConstructorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SaveOwner");

	Params::B_Perk_C_Constructor_BASE_C_SaveOwner Parms{};

	Parms.Param_ConstructorPawn = Param_ConstructorPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ApplyTrapEffects
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::ApplyTrapEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ApplyTrapEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ShowHiddenMeshes
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::ShowHiddenMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ShowHiddenMeshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BaseIsReadyToAnimate
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::BaseIsReadyToAnimate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BaseIsReadyToAnimate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ResourcesCollected
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::ResourcesCollected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ResourcesCollected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.ResourcesCreated
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::ResourcesCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "ResourcesCreated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BlueprintOnInteract
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::BlueprintOnInteract(const class AFortPawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BlueprintOnInteract");

	Params::B_Perk_C_Constructor_BASE_C_BlueprintOnInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.StopBuildingActorVisuals
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class ABuildingSMActor*                 BuildingActor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             EffectMeshComp                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::StopBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "StopBuildingActorVisuals");

	Params::B_Perk_C_Constructor_BASE_C_StopBuildingActorVisuals Parms{};

	Parms.BuildingActor = BuildingActor;
	Parms.EffectMeshComp = EffectMeshComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.StartBuildingActorVisuals
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class ABuildingSMActor*                 BuildingActor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             EffectMeshComp                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::StartBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "StartBuildingActorVisuals");

	Params::B_Perk_C_Constructor_BASE_C_StartBuildingActorVisuals Parms{};

	Parms.BuildingActor = BuildingActor;
	Parms.EffectMeshComp = EffectMeshComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.AnimateLegs
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LegsUp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Perk_C_Constructor_BASE_C::AnimateLegs(bool LegsUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "AnimateLegs");

	Params::B_Perk_C_Constructor_BASE_C_AnimateLegs Parms{};

	Parms.LegsUp = LegsUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BndEvt__Sphere_K2Node_ComponentBoundEvent_267_ComponentEndOverlapSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::BndEvt__Sphere_K2Node_ComponentBoundEvent_267_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BndEvt__Sphere_K2Node_ComponentBoundEvent_267_ComponentEndOverlapSignature__DelegateSignature");

	Params::B_Perk_C_Constructor_BASE_C_BndEvt__Sphere_K2Node_ComponentBoundEvent_267_ComponentEndOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BndEvt__Sphere_K2Node_ComponentBoundEvent_264_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AB_Perk_C_Constructor_BASE_C::BndEvt__Sphere_K2Node_ComponentBoundEvent_264_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BndEvt__Sphere_K2Node_ComponentBoundEvent_264_ComponentBeginOverlapSignature__DelegateSignature");

	Params::B_Perk_C_Constructor_BASE_C_BndEvt__Sphere_K2Node_ComponentBoundEvent_264_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.Recycling
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::Recycling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "Recycling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.OnPlaced
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          InstigatorAbilitySystemComponent                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::OnPlaced(class UAbilitySystemComponent* InstigatorAbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "OnPlaced");

	Params::B_Perk_C_Constructor_BASE_C_OnPlaced Parms{};

	Parms.InstigatorAbilitySystemComponent = InstigatorAbilitySystemComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetupBaseDefaultValues
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Ability_System_Component                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_NodesToAffect                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SetupBaseDefaultValues(class UAbilitySystemComponent* Ability_System_Component, int32* Param_NodesToAffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetupBaseDefaultValues");

	Params::B_Perk_C_Constructor_BASE_C_SetupBaseDefaultValues Parms{};

	Parms.Ability_System_Component = Ability_System_Component;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_NodesToAffect != nullptr)
		*Param_NodesToAffect = Parms.Param_NodesToAffect;
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.Setup Base Effect Array
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Instigator_Ability_System                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FBASEGameplayEffect>      BASEBuildingEffects                                    (Parm, OutParm, ZeroConstructor)
// TArray<struct FBASEGameplayEffect>      BASEFriendlyEffects                                    (Parm, OutParm, ZeroConstructor)
// TArray<struct FBASEGameplayEffect>      BASEHostileEffects                                     (Parm, OutParm, ZeroConstructor)

void AB_Perk_C_Constructor_BASE_C::Setup_Base_Effect_Array(class UAbilitySystemComponent* Instigator_Ability_System, TArray<struct FBASEGameplayEffect>* BASEBuildingEffects, TArray<struct FBASEGameplayEffect>* BASEFriendlyEffects, TArray<struct FBASEGameplayEffect>* BASEHostileEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "Setup Base Effect Array");

	Params::B_Perk_C_Constructor_BASE_C_Setup_Base_Effect_Array Parms{};

	Parms.Instigator_Ability_System = Instigator_Ability_System;

	UObject::ProcessEvent(Func, &Parms);

	if (BASEBuildingEffects != nullptr)
		*BASEBuildingEffects = std::move(Parms.BASEBuildingEffects);

	if (BASEFriendlyEffects != nullptr)
		*BASEFriendlyEffects = std::move(Parms.BASEFriendlyEffects);

	if (BASEHostileEffects != nullptr)
		*BASEHostileEffects = std::move(Parms.BASEHostileEffects);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetupBuildingEffects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Param_AbilitySystemComponent                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FBASEGameplayEffect>      BuildingEffects                                        (Parm, OutParm, ZeroConstructor)

void AB_Perk_C_Constructor_BASE_C::SetupBuildingEffects(class UAbilitySystemComponent* Param_AbilitySystemComponent, TArray<struct FBASEGameplayEffect>* BuildingEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetupBuildingEffects");

	Params::B_Perk_C_Constructor_BASE_C_SetupBuildingEffects Parms{};

	Parms.Param_AbilitySystemComponent = Param_AbilitySystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (BuildingEffects != nullptr)
		*BuildingEffects = std::move(Parms.BuildingEffects);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetupFriendlyEffects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Param_AbilitySystemComponent                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FBASEGameplayEffect>      FriendlyEffects                                        (Parm, OutParm, ZeroConstructor)

void AB_Perk_C_Constructor_BASE_C::SetupFriendlyEffects(class UAbilitySystemComponent* Param_AbilitySystemComponent, TArray<struct FBASEGameplayEffect>* FriendlyEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetupFriendlyEffects");

	Params::B_Perk_C_Constructor_BASE_C_SetupFriendlyEffects Parms{};

	Parms.Param_AbilitySystemComponent = Param_AbilitySystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (FriendlyEffects != nullptr)
		*FriendlyEffects = std::move(Parms.FriendlyEffects);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetupHostileEffects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Param_AbilitySystemComponent                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FBASEGameplayEffect>      HostileEffects                                         (Parm, OutParm, ZeroConstructor)

void AB_Perk_C_Constructor_BASE_C::SetupHostileEffects(class UAbilitySystemComponent* Param_AbilitySystemComponent, TArray<struct FBASEGameplayEffect>* HostileEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetupHostileEffects");

	Params::B_Perk_C_Constructor_BASE_C_SetupHostileEffects Parms{};

	Parms.Param_AbilitySystemComponent = Param_AbilitySystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (HostileEffects != nullptr)
		*HostileEffects = std::move(Parms.HostileEffects);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.RecycleResources
// (Public, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::RecycleResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "RecycleResources");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.OnRep_BaseIsPlaced
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::OnRep_BaseIsPlaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "OnRep_BaseIsPlaced");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SpawnResourceForRecycling
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFortWorldItemDefinition*         ItemDefinition                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AmountToSpawn                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EFortResourceType                       Param_ResourceType                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SpawnResourceForRecycling(class UFortWorldItemDefinition* ItemDefinition, int32 AmountToSpawn, EFortResourceType Param_ResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SpawnResourceForRecycling");

	Params::B_Perk_C_Constructor_BASE_C_SpawnResourceForRecycling Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.AmountToSpawn = AmountToSpawn;
	Parms.Param_ResourceType = Param_ResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.AddResourceToStack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStructRecyclingResource         RecyclingResource                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UFortWorldItemDefinition*         Stored_Resource                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AmountToSpawn                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FStructRecyclingResource         SetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::AddResourceToStack(const struct FStructRecyclingResource& RecyclingResource, class UFortWorldItemDefinition* Stored_Resource, int32 AmountToSpawn, struct FStructRecyclingResource* SetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "AddResourceToStack");

	Params::B_Perk_C_Constructor_BASE_C_AddResourceToStack Parms{};

	Parms.RecyclingResource = std::move(RecyclingResource);
	Parms.Stored_Resource = Stored_Resource;
	Parms.AmountToSpawn = AmountToSpawn;

	UObject::ProcessEvent(Func, &Parms);

	if (SetValue != nullptr)
		*SetValue = std::move(Parms.SetValue);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.OnRep_CollectResources
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::OnRep_CollectResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "OnRep_CollectResources");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetDamageMultiplier
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::SetDamageMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetDamageMultiplier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetBaseVisualGlow
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Param_AbilitySystemComponent                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SetBaseVisualGlow(class UAbilitySystemComponent* Param_AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetBaseVisualGlow");

	Params::B_Perk_C_Constructor_BASE_C_SetBaseVisualGlow Parms{};

	Parms.Param_AbilitySystemComponent = Param_AbilitySystemComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BaseSelfApplyGameplaySpec
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayEffectSpecHandle        GE_Spec                                                (BlueprintVisible, BlueprintReadOnly, Parm)

void AB_Perk_C_Constructor_BASE_C::BaseSelfApplyGameplaySpec(const struct FGameplayEffectSpecHandle& GE_Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BaseSelfApplyGameplaySpec");

	Params::B_Perk_C_Constructor_BASE_C_BaseSelfApplyGameplaySpec Parms{};

	Parms.GE_Spec = std::move(GE_Spec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.OnRep_InitialStaticMeshAnimationIsComplete
// (BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::OnRep_InitialStaticMeshAnimationIsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "OnRep_InitialStaticMeshAnimationIsComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.GetTrapGEFromTag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            InTag                                                  (BlueprintVisible, BlueprintReadOnly, Parm)
// class UClass*                           OutGE                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::GetTrapGEFromTag(const struct FGameplayTagContainer& InTag, class UClass** OutGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "GetTrapGEFromTag");

	Params::B_Perk_C_Constructor_BASE_C_GetTrapGEFromTag Parms{};

	Parms.InTag = std::move(InTag);

	UObject::ProcessEvent(Func, &Parms);

	if (OutGE != nullptr)
		*OutGE = Parms.OutGE;
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetupTrapEffects
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          AbilityComponent                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SetupTrapEffects(class UAbilitySystemComponent* AbilityComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetupTrapEffects");

	Params::B_Perk_C_Constructor_BASE_C_SetupTrapEffects Parms{};

	Parms.AbilityComponent = AbilityComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SetHealingMultiplier
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_Perk_C_Constructor_BASE_C::SetHealingMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SetHealingMultiplier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.SpawnResourceWithAmount
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFortWorldItemDefinition*         ItemDefinition                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AmountToSpawn                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EFortResourceType                       Param_ResourceType                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::SpawnResourceWithAmount(class UFortWorldItemDefinition* ItemDefinition, int32 AmountToSpawn, EFortResourceType Param_ResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "SpawnResourceWithAmount");

	Params::B_Perk_C_Constructor_BASE_C_SpawnResourceWithAmount Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.AmountToSpawn = AmountToSpawn;
	Parms.Param_ResourceType = Param_ResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.GetFeelTheBaseTraceLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTransform                       TraceLocation                                          (Parm, OutParm, IsPlainOldData, NoDestructor)

void AB_Perk_C_Constructor_BASE_C::GetFeelTheBaseTraceLocation(struct FTransform* TraceLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "GetFeelTheBaseTraceLocation");

	Params::B_Perk_C_Constructor_BASE_C_GetFeelTheBaseTraceLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TraceLocation != nullptr)
		*TraceLocation = std::move(Parms.TraceLocation);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.UpdateAudioCrossfade
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundBase*                       Sound                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_Perk_C_Constructor_BASE_C::UpdateAudioCrossfade(class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "UpdateAudioCrossfade");

	Params::B_Perk_C_Constructor_BASE_C_UpdateAudioCrossfade Parms{};

	Parms.Sound = Sound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BlueprintCanInteract
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_Perk_C_Constructor_BASE_C::BlueprintCanInteract(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BlueprintCanInteract");

	Params::B_Perk_C_Constructor_BASE_C_BlueprintCanInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_Perk_C_Constructor_BASE.B_Perk_C_Constructor_BASE_C.BlueprintGetInteractionString
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AB_Perk_C_Constructor_BASE_C::BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Perk_C_Constructor_BASE_C", "BlueprintGetInteractionString");

	Params::B_Perk_C_Constructor_BASE_C_BlueprintGetInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

